package gate

import (
	"github.com/glide-im/glide/pkg/messages"
	"strings"
)

// tempIdPrefix is the prefix for temporary IDs in the second part of the ID.
const tempIdPrefix = "tmp@"

// idSeparator is the separator used to separate the part of the ID.
const idSeparator = "_"

// ID is used to identify the client, the ID is consist of multiple parts, some of them are optional.
// The ID is constructed by concatenating the parts with a '_' separator, and the parts are:
//	- The gateway id (optional): the string id of the gateway that the client is connected to.
//	- The client id (required): the string id  of the client, it is unique for user.
//		- if the client is temporary, this id is a string generated by the gateway and start with `tmp`.
//	- The client type (optional): the int type of the client, like 'web', 'mobile', 'desktop', etc.
type ID string

// NewID2 creates a new ID from the given user id, use the empty gateway id and the empty client type.
func NewID2(uid string) ID {
	return ID(strings.Join([]string{"", uid, ""}, idSeparator))
}

// NewID creates a new ID from the given user id, gateway id and client type.
func NewID(gate string, uid string, device string) ID {
	return ID(strings.Join([]string{gate, uid, device}, idSeparator))
}

// Device returns the device type of the client, if the client device type is not set, it returns "".
func (i *ID) Device() string {
	return i.getPart(2)
}

// UID returns the user id of the client, if the client is temporary, it returns "".
func (i *ID) UID() string {
	return i.getPart(1)
}

// Gateway returns the gateway id of the client, if not set, it returns an empty string.
func (i *ID) Gateway() string {
	return i.getPart(0)
}

// SetGateway sets the gateway part of the ID.
func (i *ID) SetGateway(gateway string) bool {
	if strings.HasPrefix(string(*i), gateway) {
		return false
	}
	s := strings.Split(string(*i), idSeparator)
	if len(s) != 3 {
		return false
	}
	s[0] = gateway
	*i = ID(strings.Join(s, idSeparator))
	return true
}

// SetDevice sets the device type of the client.
func (i *ID) SetDevice(device string) bool {
	if strings.HasSuffix(string(*i), device) {
		return false
	}
	s := strings.Split(string(*i), idSeparator)
	if len(s) != 3 {
		return false
	}
	s[2] = device
	*i = ID(strings.Join(s, idSeparator))
	return true
}

// IsTemp returns true if the ID is a temporary.
func (i *ID) IsTemp() bool {
	return strings.HasPrefix(i.getPart(1), tempIdPrefix)
}

func (i *ID) getPart(index int) string {
	s := strings.Split(string(*i), idSeparator)
	if index >= len(s) {
		return ""
	}
	return s[index]
}

// Info represents a client's information.
type Info struct {

	// ID is the unique identifier for the client.
	ID ID

	// Version is the version of the client.
	Version string

	// AliveAt is the time the client was last seen.
	AliveAt int64

	// ConnectionAt is the time the client was connected.
	ConnectionAt int64

	// Gateway is the name of the gateway the client is connected to.
	Gateway string

	// CliAddr is the address of the client.
	CliAddr string
}

// Client is a client connection abstraction.
type Client interface {

	// SetID sets the ID of the client.
	SetID(id ID)

	// IsRunning returns true if the client is running/alive.
	IsRunning() bool

	// EnqueueMessage enqueues a message to be sent to the client.
	EnqueueMessage(message *messages.GlideMessage) error

	// Exit the client and close the connection.
	Exit()

	// Run starts the client message handling loop and blocks until the client.
	Run()

	// GetInfo returns the client's information.
	GetInfo() Info

	// Logged returns true if the client is logged in.
	Logged() bool
}
